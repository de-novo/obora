{
  "caseId": "monorepo-vs-multirepo",
  "caseName": "모노레포 vs 멀티레포 전략",
  "caseType": "tech",
  "category": "architecture",
  "controversyLevel": "high",
  "singleAI": {
    "response": "# 코드 저장소 전략 추천\n\n## 결론: **A) 모노레포 통합** 추천\n\n현재 상황과 성장 계획을 고려할 때, 모노레포가 가장 적합합니다.\n\n---\n\n## 판단 근거\n\n### 현재 문제점과 모노레포의 해결\n\n| 현재 문제 | 모노레포 해결 방식 |\n|----------|------------------|\n| 공유 라이브러리 버전 불일치 | 단일 버전, 즉시 동기화 |\n| 통합 테스트 어려움 | 한 번의 CI로 전체 검증 |\n| PR 리뷰 분산 | 관련 변경사항 단일 PR로 통합 |\n\n### 팀 구조와의 적합성\n\n```\n현재: 8명 풀스택 → 모두가 여러 서비스 터치\n      ↓\n모노레포의 핵심 장점: 크로스-서비스 변경이 원자적(atomic)\n```\n\n**예시**: API 스키마 변경 시\n- 멀티레포: API PR → 라이브러리 PR → 웹1 PR → 웹2 PR → 모바일 PR (5개 PR, 순차 머지)\n- 모노레포: 1개 PR로 전체 변경, 통합 테스트 후 머지\n\n### 규모 적합성\n\n```\n         소규모            중규모              대규모\n         (~5명)          (5-30명)           (100명+)\n           │                │                  │\n   멀티레포 OK      ★ 모노레포 최적      조직별 분리 고려\n                          ↑\n                       현재 위치\n```\n\n8명 → 15명 규모는 모노레포의 **스위트 스팟**입니다.\n\n---\n\n## 옵션별 비교\n\n### B) 멀티레포 유지 - 왜 비추천인가\n\n```\n현재 6개 레포 → 1년 후 10개+ 레포\n           ↓\n- 라이브러리 버전 관리 복잡도 O(n²)\n- 크로스-레포 변경마다 여러 PR 조율\n- 15명이 10개 레포 컨텍스트 스위칭\n```\n\n공유 라이브러리 \"개선\"으로 해결하려면:\n- 별도 npm 레지스트리 운영\n- 시맨틱 버저닝 + breaking change 관리\n- 결국 모노레포보다 더 복잡해짐\n\n### C) 하이브리드 - 왜 비추천인가\n\n```\n프론트엔드 모노레포 + API 별도\n          ↓\nAPI-프론트엔드 경계에서 동일한 문제 발생:\n- 공유 타입/스키마 버전 불일치\n- 통합 테스트 여전히 크로스-레포\n```\n\n하이브리드는 **\"팀이 명확히 분리된 경우\"** 에만 의미 있음 (현재 상황 아님)\n\n---\n\n## 도구 선택: Turborepo vs Nx\n\n| 기준 | Turborepo | Nx |\n|-----|-----------|-----|\n| 학습 곡선 | 낮음 ✓ | 높음 |\n| 설정 복잡도 | 간단 ✓ | 상세 |\n| 기능 범위 | 빌드 캐싱 중심 | 풀 프레임워크 |\n| 8-15명 팀 | 적합 ✓ | 과할 수 있음 |\n\n**추천: Turborepo**로 시작, 필요시 Nx로 전환\n\n---\n\n## 마이그레이션 전략\n\n```\nPhase 1: 공유 라이브러리 통합 (1-2주)\n├── 새 모노레포 생성\n├── 3개 공유 라이브러리 이동\n└── 내부 의존성으로 전환\n\nPhase 2: 백엔드 통합 (1주)\n└── API 서버 이동\n\nPhase 3: 프론트엔드 통합 (1-2주)\n├── 웹 프론트엔드 2개 이동\n└── 모바일 앱 이동\n\nPhase 4: CI/CD 통합 (1주)\n└── 영향받은 프로젝트만 빌드/배포\n```\n\n---\n\n## 주의사항\n\n1. **CI 최적화 필수**: 변경된 부분만 빌드하도록 설정 (Turborepo가 자동 지원)\n2. **CODEOWNERS 설정**: 서비스별 담당자 지정으로 리뷰 부담 분산\n3. **초기 투자**: 마이그레이션에 2-4주 소요, 하지만 장기적으로 회수\n\n---\n\n**요약**: 8명 풀스택 팀이 크로스-서비스 작업을 자주 한다면, 모노레포는 \"있으면 좋은 것\"이 아니라 **생산성을 위한 필수 선택**입니다.",
    "timeMs": 35350
  },
  "multiParallel": {
    "responses": [
      {
        "ai": "claude",
        "content": "# 코드 저장소 전략 분석\n\n## 추천: **A) 모노레포로 통합**\n\n현재 상황에서 모노레포가 가장 적합합니다.\n\n---\n\n## 핵심 판단 근거\n\n### 현재 문제와 해결책 매칭\n\n| 문제 | 모노레포 해결 방식 |\n|------|-------------------|\n| 공유 라이브러리 버전 불일치 | 단일 버전, 변경 즉시 모든 서비스에 반영 |\n| 통합 테스트 어려움 | 하나의 CI에서 전체 영향도 테스트 가능 |\n| PR 리뷰 분산 | 관련 변경사항 하나의 PR로 통합 |\n\n### 팀 구조와의 적합성\n\n**\"8명 풀스택, 모두가 여러 서비스 터치\"** — 이 구조가 결정적입니다.\n\n- 멀티레포: 하나의 기능에 6개 레포 PR → 컨텍스트 스위칭 비용 높음\n- 모노레포: 하나의 PR에서 API + 프론트 + 라이브러리 동시 변경\n\n---\n\n## 왜 B, C가 아닌가\n\n### B) 멀티레포 유지 + 라이브러리 개선\n- 버전 동기화 도구(Renovate 등) 도입해도 **근본적 문제 해결 안됨**\n- 팀이 15명 되면 조율 비용이 기하급수적 증가\n- \"공유 라이브러리 변경 → 6개 레포 업데이트 PR\" 반복\n\n### C) 하이브리드 (프론트엔드만 모노레포)\n- API-프론트 경계에서 **같은 문제 재발생**\n- 풀스택 팀에서 프론트/백엔드 분리 레포는 오히려 비효율\n- 관리 복잡도만 증가\n\n---\n\n## 모노레포 도입 시 고려사항\n\n### 도구 선택\n\n```\nTurborepo: 설정 간단, 학습곡선 낮음 → 8명 팀에 적합\nNx: 기능 풍부, 대규모 확장성 → 오버엔지니어링 우려\n```\n\n**권장: Turborepo로 시작**, 필요시 Nx 전환\n\n### 예상 구조\n\n```\n/\n├── apps/\n│   ├── api/\n│   ├── web-app/\n│   ├── web-admin/\n│   └── mobile/\n├── packages/\n│   ├── shared-types/\n│   ├── ui-components/\n│   └── utils/\n└── turbo.json\n```\n\n### 마이그레이션 리스크\n\n| 우려 | 대응 |\n|------|------|\n| CI 빌드 시간 증가 | Turborepo 캐싱으로 변경분만 빌드 |\n| 레포 크기 비대 | 모바일 바이너리는 Git LFS 또는 별도 관리 |\n| 권한 관리 | CODEOWNERS로 디렉토리별 리뷰어 지정 |\n\n---\n\n## 결론\n\n**지금 모노레포로 통합하세요.**\n\n- 8명 → 15명 성장 과정에서 멀티레포 조율 비용이 급증\n- 현재 6개 레포는 마이그레이션 가능한 규모\n- 팀 전원이 풀스택으로 일하는 구조에 모노레포가 자연스럽게 맞음\n\n나중에 팀이 30명 이상, 명확한 도메인 분리가 생기면 그때 일부 분리를 검토해도 늦지 않습니다."
      },
      {
        "ai": "codex",
        "content": "A) 모노레포를 추천합니다.\n\n이 상황에서는 “모두가 여러 서비스 터치” + “공유 라이브러리 불일치” + “통합 테스트 어려움”이 핵심 병목이라, 모노레포의 장점(단일 버전/단일 CI/단일 리뷰 플로우)이 바로 문제를 겨냥합니다. 1년 내 팀과 서비스가 빠르게 늘어난다면, 지금 일찍 통합해서 운영 규칙과 툴링을 안정화하는 편이 비용이 낮습니다.\n\n왜 A가 유리한가\n- 공유 라이브러리 버전 불일치를 원천적으로 제거(단일 소스, 단일 버전)\n- 통합 테스트, 릴리스 관리, 호환성 체크가 쉬움(같은 커밋 기반)\n- PR 리뷰와 코드 탐색이 중앙화되어 협업 비용 감소\n- 팀 증가 시 “서비스별 소유권” 대신 “도메인/기능 오너십”으로 전환하기 쉬움\n\nB의 리스크\n- 공유 라이브러리 개선만으로는 통합 테스트/리뷰 분산 문제가 해결되지 않음\n- 팀과 서비스가 늘수록 레포 간 변경 비용이 기하급수적으로 증가\n\nC의 리스크\n- 프론트만 묶으면 핵심 병목(공유 라이브러리, API-앱 간 통합)을 그대로 둠\n- 결국 1~2년 뒤 다시 통합을 고민할 가능성 큼(이중 마이그레이션 비용)\n\n운영 팁(짧게)\n- 모노레포 전환 시 “코드 오너/도메인 폴더/CI 분리 실행”을 함께 설계\n- Nx/Turborepo 중 하나를 선택해 캐시/증분 빌드/테스트를 빠르게 세팅\n\n원하시면 현재 스택(언어, 패키지 매니저, 배포 방식)에 맞춰 모노레포 구조와 마이그레이션 순서를 더 구체화해 드릴게요."
      }
    ],
    "timeMs": 27136
  },
  "multiDebate": {
    "rounds": [
      {
        "ai": "claude",
        "content": "# 권장안: A) 모노레포로 통합 (Turborepo 추천)\n\n## 결정 근거\n\n### 현재 상황이 모노레포에 최적화된 이유\n\n1. **팀 구조와 일치**\n   - 8명 전원이 여러 서비스를 터치하는 풀스택 구조\n   - 멀티레포는 팀이 서비스별로 분리되어 있을 때 유리함\n   - 현재 구조에서 6개 레포는 불필요한 컨텍스트 스위칭만 유발\n\n2. **현재 문제를 직접 해결**\n   - 공유 라이브러리 버전 불일치 → 단일 버전으로 해결\n   - 통합 테스트 어려움 → 하나의 CI에서 전체 테스트 실행\n   - PR 리뷰 분산 → 연관 변경을 하나의 PR로 처리\n\n3. **규모가 적절**\n   - 7개 프로젝트(서비스 4개 + 라이브러리 3개)는 모노레포로 관리하기 적합\n   - 마이그레이션 비용이 아직 낮음\n\n### Turborepo를 Nx보다 추천하는 이유\n\n| 기준 | Turborepo | Nx |\n|------|-----------|-----|\n| 학습 곡선 | 낮음 | 높음 |\n| 설정 복잡도 | 간단 | 복잡 |\n| 8~15명 팀 | 충분 | 과함 |\n| 마이그레이션 | 빠름 | 느림 |\n\nNx는 50명 이상 팀에서 진가 발휘. 현재 규모에는 과도함.\n\n## 잠재적 리스크와 대응\n\n### 1. 마이그레이션 비용\n- **리스크**: 2-3주 개발 속도 저하\n- **대응**: 점진적 마이그레이션. 공유 라이브러리 먼저, 서비스는 순차 통합\n\n### 2. CI 빌드 시간 증가\n- **리스크**: 모든 변경에 전체 빌드 실행 우려\n- **대응**: Turborepo의 캐싱과 affected 감지 활용 (변경된 부분만 빌드)\n\n### 3. 15명 이상 확장 시\n- **리스크**: 코드 소유권 불명확, 머지 충돌 증가\n- **대응**: CODEOWNERS 파일로 영역별 책임자 지정\n\n## 선택지 B, C를 배제한 이유\n\n**B) 멀티레포 유지 + 라이브러리 개선**\n- 근본 해결 아님. 버전 동기화를 위한 추가 도구 필요 (Changesets, Lerna)\n- 결국 모노레포 수준의 복잡도를 멀티레포에서 재구현하게 됨\n\n**C) 하이브리드 (프론트엔드만 모노레포)**\n- 풀스택 팀 구조와 맞지 않음\n- API + 프론트엔드 동시 변경 시 여전히 여러 레포 필요\n- 복잡도만 증가, 문제 해결 안 됨\n\n## 결론\n\n지금 모노레포로 통합하는 것이 **가장 비용 효율적인 시점**입니다. 팀이 15명, 서비스가 10개 이상으로 커진 후에 마이그레이션하면 비용이 3-5배 증가합니다.",
        "phase": "initial"
      },
      {
        "ai": "codex",
        "content": "A) 모노레포로 통합을 추천합니다. 지금의 문제(공유 라이브러리 버전 불일치, 통합 테스트 어려움, PR 리뷰 분산)는 “코드가 흩어져 있어 생기는 비용”이라서, 팀과 서비스가 커질수록 더 악화됩니다. 1년 내 15명/10+서비스라면 조기 통합이 장기 비용을 가장 크게 낮춥니다.\n\n근거:\n- 공유 라이브러리 버전 불일치: 모노레포는 단일 소스 오브 트루스라서 즉시 동기화·일괄 변경이 가능하고, 의존성 충돌을 구조적으로 줄입니다.\n- 통합 테스트: 서비스 간 의존성을 한 번의 CI 파이프라인에서 테스트할 수 있어 “깨진 조합”을 빨리 발견합니다.\n- PR 리뷰 분산: 변경이 한 레포에 모이므로 리뷰 기준과 프로세스를 표준화하기 쉽고, 코드 소유권/폴더 단위 CODEOWNERS로 책임을 명확히 할 수 있습니다.\n- 팀 구조: 풀스택 8명이 모든 서비스를 만지는 상황은 모노레포의 “컨텍스트 스위칭 감소” 효과가 큽니다. 앞으로 팀이 커져도 공통 규칙 유지가 유리합니다.\n\n잠재적 리스크:\n- CI 시간 증가: 레포가 커지면 빌드/테스트 시간이 늘어납니다. Nx/Turborepo의 캐싱·영향도 분석을 반드시 도입해야 합니다.\n- 권한/경계 약화: 모든 코드가 한 곳에 있으니 소유권이 흐려질 수 있습니다. 폴더별 CODEOWNERS, 릴리스 규칙, 브랜치 보호가 필요합니다.\n- 온보딩 부담: 레포 규모가 커지면 신규 개발자 온보딩이 어렵습니다. 명확한 디렉터리 구조와 개발 가이드가 필요합니다.\n- 툴링 복잡도: 모노레포 도구를 제대로 운영하지 않으면 빌드가 느려지거나 규칙이 깨집니다. 초기 설정에 시간을 투자해야 합니다.\n\n결론: 현재 문제의 성격과 1년 내 성장 전망을 보면, 모노레포가 가장 높은 ROI를 제공합니다. Nx나 Turborepo 중 하나로 통합하고, 캐싱/영향도 기반 CI, CODEOWNERS, 릴리스 정책을 함께 설계하는 것을 권장합니다.",
        "phase": "initial"
      },
      {
        "ai": "claude",
        "content": "# 모노레포 통합 제안에 대한 비판적 검토\n\n## 1. 마이그레이션 비용을 심각하게 과소평가함\n\n**제안에서 빠진 현실:**\n- 6개 레포를 통합하면서 기존 git 히스토리를 보존하는 작업은 **최소 2-4주의 전담 인력**이 필요\n- 마이그레이션 기간 동안 기능 개발이 멈추거나 충돌 발생\n- 기존 CI/CD 파이프라인 6개를 전면 재설계해야 함\n\n**실패 시나리오:** 8명 풀스택 팀에서 2명이 모노레포 전환에 투입되면 제품 개발 속도가 25% 감소. 스타트업에서 1-2개월의 개발 지연은 치명적일 수 있음.\n\n---\n\n## 2. \"1년 내 15명, 10개 서비스\" 가정의 함정\n\n**문제점:**\n- 스타트업 성장 예측은 대부분 틀림 (과대 또는 과소)\n- 15명이 되면 **팀 분리(스쿼드/셀)가 시작**되는 시점 — 이때는 오히려 서비스별 소유권이 중요해짐\n- 10개 이상 서비스에서 모노레포는 **권한 관리 지옥**이 됨\n\n**반례:** Segment는 모노레포로 시작했다가 팀이 커지면서 마이크로서비스별 레포로 다시 분리. \"모노레포가 스케일 문제를 구조적으로 해결한다\"는 주장은 일정 규모까지만 참.\n\n---\n\n## 3. Nx/Turborepo 캐싱의 현실적 한계\n\n**제안의 낙관적 가정:**\n> \"캐싱·영향도 분석을 반드시 도입해야 합니다\"\n\n**현실:**\n- 영향도 분석은 **의존성이 명확할 때만** 작동\n- 공유 라이브러리 변경 시 결국 전체 리빌드 트리거되는 경우 빈번\n- 캐시 무효화 버그로 인한 \"왜 내 변경이 반영 안 됨?\" 디버깅 시간 증가\n- **Remote caching 비용**: Vercel/Nx Cloud 유료, 셀프호스팅은 추가 인프라 필요\n\n**실패 조건:** 공유 라이브러리 3개가 \"모든 서비스에서 사용\"되는 구조라면, 캐싱 효과는 기대의 30-40% 수준에 그침.\n\n---\n\n## 4. 진짜 문제는 모노레포로 안 풀림\n\n제안서가 나열한 문제를 다시 보면:\n\n| 문제 | 모노레포가 해결? |\n|------|-----------------|\n| 공유 라이브러리 버전 불일치 | **△** — 내부 버전은 동기화되지만, 외부 의존성(node_modules) 버전 충돌은 그대로 |\n| 통합 테스트 어려움 | **×** — 테스트 환경/인프라 문제지 레포 구조 문제가 아님 |\n| PR 리뷰 분산 | **×** — 리뷰 문화와 프로세스 문제. 모노레포에서도 폴더별로 분산됨 |\n\n**핵심 반론:** \"PR 리뷰 분산\"은 레포 개수가 아니라 **리뷰 문화와 도구**의 문제. GitHub에서 멀티레포 통합 리뷰 대시보드 만드는 게 모노레포 전환보다 빠름.\n\n---\n\n## 5. 하이브리드(C안)를 너무 쉽게 기각함\n\n**C안이 더 나을 수 있는 조건:**\n- 웹 프론트엔드 2개가 **동일 디자인 시스템/컴포넌트 공유** 중이라면, 프론트엔드만 모노레포로 묶는 게 ROI 높음\n- API 서버와 모바일 앱은 릴리스 사이클이 다름 (앱스토어 심사 등) — 같은 레포에 있으면 브랜치 전략이 복잡해짐\n- **점진적 전환** 가능 — 실패해도 롤백 범위가 작음\n\n---\n\n## 6. 누락된 치명적 고려사항\n\n### 모바일 앱이 있다\n- iOS/Android 빌드 시스템은 JS/TS 생태계와 완전히 다름\n- React Native라 해도 네이티브 모듈 빌드는 별도\n- 모노레포에 모바일 넣으면 **CI 복잡도 3배 증가**\n\n### 외부 기여자/계약자\n- 스타트업은 외부 개발자 참여 빈번\n- 모노레포에 전체 접근권 주기 어려움 → 부분 clone 필요 → 추가 복잡도\n\n---\n\n## 대안 제안: B안을 제대로 하면 충분\n\n현재 문제의 80%는 **공유 라이브러리 관리 방식**에서 옴:\n\n1. 공유 라이브러리 3개를 **private npm 패키지**로 배포 (GitHub Packages 무료)\n2. **Renovate/Dependabot**으로 자동 버전 업데이트 PR 생성\n3. 통합 테스트는 **별도 레포에 E2E 테스트 스위트** 구성\n4. PR 리뷰는 **GitHub Projects + 통합 대시보드**로 관리\n\n이 방식은:\n- 기존 인프라 유지하면서 **1-2주 내 적용 가능**\n- 실패해도 롤백 쉬움\n- 팀이 15명이 되어 스쿼드로 나뉘어도 자연스럽게 확장\n\n---\n\n## 결론\n\n모노레포 전환은 **\"지금 당장 마이그레이션 비용을 감수할 여유가 있고, 향후 팀 구조가 기능별 분업으로 가지 않을 것\"**이 확실할 때만 옳다. \n\n8명 스타트업이 1년 후 어떤 조직 구조가 될지 모르는 상황에서, 되돌리기 어려운 대규모 인프라 변경은 **과도한 선행 투자**다. B안을 먼저 최적화하고, 그래도 한계가 오면 그때 전환해도 늦지 않다.",
        "phase": "rebuttal"
      },
      {
        "ai": "codex",
        "content": "모노레포 찬반 양쪽 모두 빠진 부분과 과소평가한 리스크가 있습니다. 아래는 비판적 지적과 실패 조건입니다.\n\n**모노레포 권장 의견(claude) 문제점**\n- “현재 문제가 모노레포로 직접 해결된다”는 과장: 공유 라이브러리 버전 불일치는 해결되지만, 런타임 의존성/플랫폼별 빌드(모바일) 충돌은 그대로입니다. 실패 조건: Node/Native/Java 혼합 빌드가 단일 파이프라인에서 자주 깨지는 구조.\n- 통합 테스트 난이도는 레포 구조보다 환경/데이터/시드 전략 이슈가 큼. 실패 조건: 테스트가 서로 다른 인프라나 데이터셋을 요구할 때.\n- PR 리뷰 분산을 레포 구조 문제로 단정: 리뷰 분산은 책임자/룰/우선순위의 문제일 가능성이 큼. 실패 조건: 모노레포에서도 팀이 서브폴더에 “영역별”로 분산될 때.\n- “지금이 최적 시점” 주장에 근거 부족: 1년 후 조직 구조가 팀 분리로 갈 가능성을 배제. 실패 조건: 조직이 스쿼드로 나뉘며 소유권/배포 주기가 분리될 때.\n- Turborepo vs Nx 논의가 인프라 현실을 누락: 캐시 서버 운영, 접근 제어, 보안 요구사항(외주/파트너 포함) 비용을 무시. 실패 조건: 외부 기여자 접근 제한이 필요하거나 CI 캐시 운영 인력이 부족할 때.\n\n**모노레포 반대 의견(claude 반박) 문제점**\n- “마이그레이션 2–4주 전담”도 과장일 수 있음: 히스토리 보존이 필수인지부터 불명. 실패 조건: 히스토리 보존을 강제해서 복잡도가 급증하는 선택을 할 때.\n- “통합 테스트는 레포 구조와 무관”도 과장: 동일 리포는 테스트 실행/의존성 그래프 관리를 단순화할 수 있음. 실패 조건: 서비스 간 버전 호환성을 실제로 자주 깨뜨리는 조직.\n- “PR 리뷰는 문화 문제”라고만 보는 건 협소: 레포 분산은 실제로 리뷰 찾기 비용을 증가시킴. 실패 조건: 리뷰어가 여러 레포를 오가야 해서 늦어지는 조직.\n- 하이브리드 C안의 장점 강조가 불완전: 프론트/백엔드 동시 변경이 잦은 풀스택 팀에서는 C안이 오히려 교차 레포 PR/릴리스 지옥을 만듦. 실패 조건: API/웹/모바일 변경이 한 기능에 동시에 발생할 때.\n- “B안으로 충분”은 실행 난이도 과소평가: private 패키지 배포, 버전 정책, 호환성 테스트, 릴리스 자동화가 없으면 오히려 복잡도가 증가. 실패 조건: 패키지 버전이 늘고 호환성 규칙(semver)이 느슨할 때.\n\n**양쪽 모두 놓친 핵심**\n- 릴리스/배포 주기 분리 문제: 모바일 앱은 스토어 심사로 주기가 느리고, 서버/웹은 빠름. 실패 조건: 단일 브랜치/릴리스 전략을 강제할 때.\n- 코드 소유권/접근 제어: 모노레포든 멀티레포든 소유권 규칙과 권한 분리가 없으면 확장 시 충돌 증가. 실패 조건: CODEOWNERS/폴더 ACL이 없는 상태에서 팀이 15명 이상으로 증가.\n- 빌드/테스트 병렬성: 모노레포라도 빌드 병목(모바일 + 백엔드 + 프론트)이 생기면 생산성 하락. 실패 조건: CI 리소스가 한정적이고 병렬화가 제한될 때.\n- 기술 스택 이질성: 모바일 네이티브, 백엔드, 웹이 섞이면 개발환경 도구 체인이 달라짐. 실패 조건: OS/SDK 조건이 충돌하는 개발자 환경.\n- 변화 실패 비용: 되돌리기 전략이 양쪽 모두 부족함. 실패 조건: 전환 후 다시 분리해야 할 때 롤백 계획이 없는 경우.\n\n필요하면 “실패 조건”을 기준으로 현재 팀의 실제 작업 패턴(동시 변경 비중, 배포 주기, CI 자원, 외주 참여 여부)을 점검하는 체크리스트를 만들어 드릴게요.",
        "phase": "rebuttal"
      },
      {
        "ai": "claude",
        "content": "# 최종 권장안: 조건부 A (모노레포) 또는 강화된 B\n\n반박들을 검토한 결과, 초기 입장을 일부 수정합니다.\n\n---\n\n## 수정하는 부분\n\n### 1. 마이그레이션 비용을 과소평가했음\n\n**인정**: \"2-3주 개발 속도 저하\"는 낙관적. 현실적으로:\n- Git 히스토리 보존 + CI/CD 재설계 = **4-6주 전담 인력 필요**\n- 8명 중 2명 투입 시 제품 개발 25% 감소는 스타트업에 치명적\n\n### 2. 모바일 앱 포함의 복잡도를 간과함\n\n**인정**: iOS/Android 빌드 시스템은 JS/TS와 완전히 다름\n- React Native라도 네이티브 모듈 빌드는 별도 파이프라인\n- 앱스토어 심사로 릴리스 주기가 다름\n- **모바일은 모노레포에서 제외하는 것이 현실적**\n\n### 3. \"PR 리뷰 분산\"은 레포 구조만의 문제가 아님\n\n**인정**: 리뷰 문화와 프로세스가 더 큰 변수. 모노레포로 바꿔도 폴더별로 분산될 수 있음.\n\n---\n\n## 여전히 유지하는 입장\n\n### 1. 공유 라이브러리 버전 불일치는 모노레포가 확실히 해결\n\n반박에서 \"B안으로 충분\"이라 했지만:\n\n```\n멀티레포 + private npm 패키지 방식의 현실:\n├── 라이브러리 변경\n├── npm publish\n├── 6개 레포에 PR 생성 (Renovate)\n├── 각 레포에서 테스트 통과 확인\n├── 각 레포에서 머지\n└── 총 소요: 반나절 ~ 하루\n```\n\n```\n모노레포 방식:\n├── 라이브러리 변경\n├── 영향받는 서비스와 함께 단일 PR\n├── 한 번에 테스트, 한 번에 머지\n└── 총 소요: 30분 ~ 1시간\n```\n\n**8명 풀스택 팀이 매주 공유 라이브러리를 수정한다면**, 이 차이는 연간 수백 시간.\n\n### 2. 팀 구조(풀스택, 기능별 분업 없음)가 핵심 판단 기준\n\n반박에서 \"15명이 되면 스쿼드로 나뉜다\"고 했지만:\n- **현재 조직 구조에 맞게 결정**하는 것이 맞음\n- 1년 후 스쿼드로 나뉘면 그때 분리 검토\n- \"미래에 바뀔 수도 있으니 지금 불편함을 감수하자\"는 논리는 약함\n\n### 3. B안(멀티레포 + 패키지 개선)은 결국 모노레포 복잡도를 재구현\n\n```\nB안 제대로 하려면 필요한 것:\n├── Private npm registry 운영\n├── Semantic versioning 정책 수립\n├── Changesets 또는 유사 도구 도입\n├── 자동 버전 업데이트 봇 설정\n├── 크로스레포 E2E 테스트 환경 구축\n├── 통합 리뷰 대시보드 구축\n└── 결과: 모노레포 수준의 인프라 복잡도\n```\n\n---\n\n## 최종 권장안: 결정 트리\n\n현재 상황을 정확히 파악한 후 결정해야 합니다:\n\n```\nQ1. 모바일 앱이 React Native인가, 네이티브인가?\n    │\n    ├─ 네이티브 (Swift/Kotlin)\n    │   └─ 모바일은 무조건 별도 레포 유지\n    │\n    └─ React Native\n        └─ Q2로 진행\n\nQ2. 공유 라이브러리 변경 빈도는?\n    │\n    ├─ 주 1회 이상 → A안 (모노레포) 강력 추천\n    │\n    └─ 월 1-2회 → Q3으로 진행\n\nQ3. 향후 6개월 내 외부 개발자(외주/파트너) 참여 예정?\n    │\n    ├─ 예 → B안 (멀티레포 + 패키지 개선)\n    │\n    └─ 아니오 → A안 (모노레포)\n```\n\n---\n\n## 시나리오별 구체적 권장\n\n### 시나리오 1: A안 선택 시 (모노레포)\n\n**구조**:\n```\nmonorepo/\n├── apps/\n│   ├── api-server/\n│   ├── web-app-1/\n│   └── web-app-2/\n├── packages/\n│   ├── shared-lib-1/\n│   ├── shared-lib-2/\n│   └── shared-lib-3/\n└── mobile/  ← 별도 레포로 유지, git submodule로 연결\n```\n\n**핵심 조건**:\n- 모바일 앱은 제외 (별도 레포)\n- Turborepo 사용 (Nx는 과도함)\n- Remote caching은 Vercel 무료 티어로 시작\n- CODEOWNERS 첫 날부터 설정\n\n**마이그레이션 전략**:\n1. 새 모노레포 생성, 공유 라이브러리 3개 먼저 이동 (1주)\n2. 웹 프론트엔드 2개 이동 (1주)\n3. API 서버 이동 (1주)\n4. 기존 레포는 읽기 전용으로 아카이브\n\n### 시나리오 2: B안 선택 시 (멀티레포 강화)\n\n**필수 구현 사항**:\n```\n1. GitHub Packages로 공유 라이브러리 배포\n2. Changesets으로 버전 관리 자동화\n3. Renovate로 의존성 업데이트 자동화\n4. GitHub Actions로 크로스레포 E2E 테스트\n5. GitHub Projects로 통합 이슈/PR 관리\n```\n\n**이 방식이 실패하는 조건**:\n- 공유 라이브러리 변경이 주 2회 이상\n- semver 규칙을 팀이 지키지 않음\n- E2E 테스트 환경 구축에 2주 이상 소요\n\n---\n\n## 최종 결론\n\n| 조건 | 권장안 |\n|------|--------|\n| 공유 라이브러리 변경 빈번 + 외부 개발자 없음 | **A (모노레포, 모바일 제외)** |\n| 변경 빈도 낮음 또는 외부 개발자 있음 | **B (멀티레포 + 패키지 개선)** |\n| 확신이 없음 | **B로 시작, 3개월 후 재평가** |\n\n**C안(하이브리드)은 여전히 비추천**. 풀스택 팀 구조에서 레포를 나누는 기준이 \"프론트엔드 vs 백엔드\"가 되면 오히려 혼란만 증가.\n\n---\n\n가장 중요한 것은 **현재 공유 라이브러리 변경 빈도**입니다. 이 데이터 하나가 결정을 좌우합니다.",
        "phase": "revised"
      },
      {
        "ai": "codex",
        "content": "수정할 부분부터 짚겠습니다.\n\nA안(모노레포) 단독 권장을 “무조건”으로 몰고 갔던 초기 입장은 수정합니다. 특히 두 가지는 과소평가였습니다.  \n1) 마이그레이션 비용: 히스토리 보존/CI 재설계/권한 정책까지 고려하면 4–6주 전담이 현실적입니다.  \n2) 모바일 포함: 네이티브 빌드/스토어 심사 주기 때문에 “같은 레포”가 오히려 병목이 될 수 있습니다. 모바일은 별도 레포 유지가 더 현실적입니다.\n\n그럼에도 유지하는 핵심 입장은 있습니다. “공유 라이브러리 변경이 잦고, 풀스택 팀이 서비스 전반을 동시에 건드리는 구조라면 모노레포가 장기 비용을 가장 크게 줄인다”는 점입니다. 방어 근거는 다음입니다.\n\n- **버전 불일치 문제는 구조적**입니다. 멀티레포에서 이를 해결하려면 패키지 배포+버전 정책+자동 업데이트+E2E 통합 테스트를 모두 갖춰야 합니다. 즉, 모노레포와 유사한 운영 복잡도를 “레포 밖”에서 재구현하게 됩니다.  \n- **동시 변경 비용**이 결정적입니다. 한 기능이 API+웹+공유 라이브러리를 함께 건드리는 빈도가 높을수록, 멀티레포는 PR/릴리스 수가 기하급수적으로 증가합니다. 이건 문화가 아니라 구조가 만드는 비용입니다.  \n- **풀스택 팀 구조**는 모노레포와 가장 잘 맞습니다. 지금 조직이 서비스별 소유권이 아니라 기능 단위로 움직인다면, 레포 분리는 물리적으로 불필요한 경계를 만드는 셈입니다.\n\n최종 권장안은 “조건부 A”입니다. 결정 기준을 명확히 하겠습니다.\n\n**결정 트리**\n1) 모바일이 네이티브인가?  \n- 예: 모바일은 **별도 레포 유지**  \n- 아니오(RN 포함): 모바일을 넣을지 분리할지는 CI 복잡도/릴리스 주기로 결정\n\n2) 공유 라이브러리 변경 빈도는?  \n- 주 1회 이상: **A(모노레포, 모바일 제외) 강력 추천**  \n- 월 1~2회 이하: **B(멀티레포 강화) 가능**\n\n3) 외부 개발자/파트너 참여가 잦은가?  \n- 예: **B가 더 안전** (접근 권한/부분 공개 문제 최소화)  \n- 아니오: **A가 비용 효율적**\n\n---\n\n**최종 권장안**  \n- 현재 정보만 보면: **A(모노레포) + 모바일 별도 레포 유지**가 가장 합리적입니다.  \n- 단, 아래 조건을 만족해야 합니다.  \n  - 공유 라이브러리 변경이 “월 2회 이하”가 아니라 “주 단위로 잦다”  \n  - 외부 기여자 접근 제어가 핵심 이슈가 아니다  \n  - CI에 캐싱/영향도 분석을 반드시 도입할 의지가 있다\n\n위 조건 중 하나라도 흔들리면 **B(멀티레포 강화)로 시작하고 3개월 후 재평가**가 안전합니다.\n\n원하시면 “3개월 재평가 체크리스트(변경 빈도/PR 리드타임/CI 시간/리뷰 분산 지표)”까지 만들어 드릴게요.",
        "phase": "revised"
      }
    ],
    "conclusion": "격렬한 토론을 정리했습니다. Claude와 Codex는 초기 입장에서 부분 수정했으며, 최종적으로 \"공유 라이브러리 변경 빈도\"와 \"외부 기여자 참여 여부\"에 따른 조건부 의사결정 트리에 합의했습니다. A안(모노레포)과 B안(멀티레포 강화) 모두 실행 가능하나, 데이터 기반 PoC를 통한 3개월 재평가 후 최종 결정하는 것을 권장합니다.",
    "timeMs": 230946
  },
  "analysis": {
    "singleLength": 1929,
    "parallelLength": 2076,
    "debateLength": 10298,
    "debateRounds": 6
  }
}