{
  "caseId": "realtime-sync-architecture",
  "caseName": "실시간 협업 동기화 설계",
  "caseType": "tech",
  "category": "architecture",
  "controversyLevel": "high",
  "singleAI": {
    "response": "# 실시간 협업 도구: 기술 선택 분석\n\n## 추천: **B) CRDT (Conflict-free Replicated Data Types)**\n\n요구사항을 분석했을 때 CRDT가 가장 적합합니다. 이유를 설명드리겠습니다.\n\n---\n\n## 세 가지 접근법 비교\n\n| 기준 | OT | CRDT | Event Sourcing + LWW |\n|------|-----|------|---------------------|\n| **오프라인 지원** | ❌ 어려움 (서버 의존) | ✅ 네이티브 지원 | ⚠️ 충돌 시 데이터 손실 |\n| **50명 동시 편집** | ⚠️ 서버 병목 | ✅ P2P 가능 | ✅ 가능 |\n| **100ms 지연** | ⚠️ 서버 왕복 필요 | ✅ 로컬 우선 적용 | ✅ 가능 |\n| **자동 충돌 해결** | ⚠️ 변환 복잡 | ✅ 수학적 보장 | ❌ 데이터 덮어쓰기 |\n| **무제한 히스토리** | ⚠️ 구현 복잡 | ✅ 자연스러운 지원 | ✅ 이벤트 저장 |\n| **구현 난이도** | 🔴 매우 높음 | 🟡 중간 | 🟢 낮음 |\n\n---\n\n## 왜 CRDT인가?\n\n### 1. 오프라인 우선 (Offline-First)\n```\nOT: 클라이언트 → 서버 → 다른 클라이언트 (서버 필수)\nCRDT: 클라이언트 ←→ 클라이언트 (서버 선택적)\n```\nCRDT는 각 클라이언트가 독립적으로 작동하고, 나중에 병합해도 **항상 같은 결과**가 보장됩니다.\n\n### 2. 수학적 충돌 해결\nCRDT는 **교환법칙, 결합법칙, 멱등성**을 만족하여:\n- 어떤 순서로 변경사항이 도착해도 동일한 결과\n- 같은 변경이 여러 번 적용되어도 안전\n- 사용자 개입 없이 자동 병합\n\n### 3. 지연시간 최소화\n```\n로컬 편집 → 즉시 UI 반영 → 백그라운드 동기화\n```\n사용자는 네트워크 지연을 느끼지 않습니다.\n\n---\n\n## 구현 전략\n\n### 아키텍처 개요\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                      클라이언트                          │\n├─────────────────────────────────────────────────────────┤\n│  ┌─────────┐    ┌─────────┐    ┌─────────────────────┐  │\n│  │  Editor │ ←→ │  CRDT   │ ←→ │  Sync Engine        │  │\n│  │   UI    │    │  Store  │    │  (WebSocket/WebRTC) │  │\n│  └─────────┘    └─────────┘    └─────────────────────┘  │\n│                      ↓                    ↓              │\n│              ┌─────────────┐    ┌─────────────────┐     │\n│              │  IndexedDB  │    │  Service Worker │     │\n│              │  (오프라인)  │    │  (백그라운드)    │     │\n│              └─────────────┘    └─────────────────┘     │\n└─────────────────────────────────────────────────────────┘\n                           ↓\n┌─────────────────────────────────────────────────────────┐\n│                       서버                               │\n├─────────────────────────────────────────────────────────┤\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │\n│  │  WebSocket   │  │   CRDT       │  │  Persistence │   │\n│  │  Gateway     │→ │   Merge      │→ │  (PostgreSQL)│   │\n│  └──────────────┘  └──────────────┘  └──────────────┘   │\n│                                             ↓            │\n│                                    ┌──────────────┐     │\n│                                    │  History     │     │\n│                                    │  (이벤트 로그)│     │\n│                                    └──────────────┘     │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 핵심 컴포넌트\n\n#### 1. CRDT 라이브러리 선택\n\n| 라이브러리 | 특징 | 추천 용도 |\n|-----------|------|----------|\n| **Yjs** | 가장 성숙, 풍부한 바인딩 | 텍스트/리치 텍스트 |\n| **Automerge** | JSON 친화적, WASM 지원 | 구조화된 데이터 |\n| **Diamond Types** | Rust 기반, 최고 성능 | 고성능 필요 시 |\n\n**추천: Yjs** - 생태계가 가장 풍부하고 프로덕션 검증됨\n\n#### 2. 데이터 모델 예시 (Notion 스타일)\n\n```typescript\ninterface Document {\n  id: string;\n  blocks: Y.Array<Block>;      // CRDT Array\n  metadata: Y.Map<any>;        // CRDT Map\n}\n\ninterface Block {\n  id: string;\n  type: 'paragraph' | 'heading' | 'list' | 'image';\n  content: Y.Text;             // CRDT Text (리치 텍스트)\n  properties: Y.Map<any>;\n  children: Y.Array<Block>;    // 중첩 구조\n}\n```\n\n#### 3. 동기화 프로토콜\n\n```\nPhase 1: 연결\n  클라이언트 → 서버: { docId, clientVector }\n  서버 → 클라이언트: { missing updates }\n\nPhase 2: 실시간 동기화\n  변경 발생 → 로컬 적용 → 델타 브로드캐스트\n  \nPhase 3: 오프라인 복구\n  재연결 → 벡터 클럭 비교 → 누락분 동기화\n```\n\n#### 4. 히스토리 구현\n\n```typescript\n// 스냅샷 + 증분 저장\ninterface HistoryEntry {\n  timestamp: number;\n  userId: string;\n  \n  // 선택 1: 전체 스냅샷 (주기적)\n  snapshot?: Uint8Array;\n  \n  // 선택 2: 증분 업데이트 (매 변경)\n  update?: Uint8Array;\n}\n\n// 되돌리기: 특정 시점 스냅샷 재구성\nfunction restoreToPoint(docId: string, timestamp: number) {\n  const baseSnapshot = findNearestSnapshot(timestamp);\n  const updates = getUpdatesSince(baseSnapshot, timestamp);\n  return applyUpdates(baseSnapshot, updates);\n}\n```\n\n---\n\n## 구현 로드맵\n\n### Phase 1: 기본 동기화\n- Yjs 통합 + 기본 텍스트 에디터\n- WebSocket 기반 실시간 동기화\n- 기본 커서 공유 (Awareness)\n\n### Phase 2: 오프라인 지원\n- IndexedDB 로컬 저장소\n- Service Worker 백그라운드 동기화\n- 연결 상태 UI\n\n### Phase 3: 히스토리\n- 스냅샷 저장 전략\n- 타임라인 UI\n- 버전 비교/복원\n\n### Phase 4: 최적화\n- 대용량 문서 청킹\n- 변경사항 압축\n- P2P (WebRTC) 옵션\n\n---\n\n## 주의사항\n\n1. **CRDT 오버헤드**: 메타데이터로 인해 문서 크기 증가 (2-3배)\n   - 해결: 주기적 가비지 컬렉션, 스냅샷 압축\n\n2. **삭제된 항목 (Tombstones)**: 삭제해도 메타데이터 유지\n   - 해결: 주기적 정리, 모든 클라이언트 동기화 후 제거\n\n3. **스키마 마이그레이션**: CRDT 구조 변경 어려움\n   - 해결: 초기 설계에 확장성 고려, 버전 관리\n\n---\n\n구체적인 구현 코드나 특정 부분에 대해 더 자세한 설명이 필요하시면 말씀해 주세요.",
    "timeMs": 48319
  },
  "multiParallel": {
    "responses": [
      {
        "ai": "claude",
        "content": "# 실시간 협업 도구: 기술 선택 분석\n\n## 결론: **B) CRDT 추천**\n\n요구사항을 분석하면 CRDT가 가장 적합합니다.\n\n---\n\n## 기술 비교\n\n| 기준 | OT | CRDT | Event Sourcing + LWW |\n|------|-----|------|----------------------|\n| **오프라인 지원** | ❌ 서버 필수 | ✅ 네이티브 지원 | ⚠️ 충돌 시 데이터 손실 |\n| **50명 동시 편집** | ⚠️ 서버 병목 | ✅ P2P 가능 | ⚠️ 서버 의존 |\n| **100ms 지연** | ⚠️ 서버 왕복 필요 | ✅ 로컬 즉시 적용 | ✅ 로컬 즉시 적용 |\n| **자동 충돌 해결** | ✅ 가능 | ✅ 수학적 보장 | ❌ 마지막 쓰기가 이김 |\n| **무제한 히스토리** | ⚠️ 복잡 | ✅ 자연스러움 | ✅ 이벤트 로그 |\n| **구현 복잡도** | 높음 | 중간 | 낮음 |\n\n---\n\n## CRDT 추천 이유\n\n### 1. 오프라인 우선 아키텍처\n```\n[사용자 A] ←→ [로컬 CRDT] ←→ [동기화 레이어] ←→ [서버]\n                  ↓\n           오프라인에서도 편집 가능\n           온라인 시 자동 병합\n```\n\n### 2. 수학적 충돌 해결\n- **교환 법칙**: A + B = B + A (순서 무관)\n- **결합 법칙**: (A + B) + C = A + (B + C)\n- **멱등성**: A + A = A (중복 적용 안전)\n\n→ 어떤 순서로 변경이 도착해도 **모든 클라이언트가 동일한 최종 상태**에 도달\n\n### 3. 지연시간 최소화\n```\nOT 방식:  [로컬 입력] → [서버 전송] → [변환] → [브로드캐스트] → [표시]\n                         ~50-200ms 지연\n\nCRDT 방식: [로컬 입력] → [즉시 표시] + [백그라운드 동기화]\n                         ~0ms 로컬 지연\n```\n\n---\n\n## 구현 전략\n\n### 권장 라이브러리\n\n| 라이브러리 | 특징 | 적합한 경우 |\n|-----------|------|------------|\n| **Yjs** | 가장 성숙, 풍부한 에코시스템 | 범용 문서 편집 |\n| **Automerge** | JSON 친화적, 직관적 API | 구조화된 데이터 |\n| **Diamond Types** | Rust 기반, 최고 성능 | 고성능 요구 |\n\n### 아키텍처 제안\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                        클라이언트                            │\n├─────────────────────────────────────────────────────────────┤\n│  [에디터 UI] ←→ [Yjs Document] ←→ [IndexedDB 캐시]          │\n│                       ↓                                      │\n│              [WebSocket Provider]                            │\n└─────────────────────────────────────────────────────────────┘\n                        ↓ WebSocket\n┌─────────────────────────────────────────────────────────────┐\n│                         서버                                 │\n├─────────────────────────────────────────────────────────────┤\n│  [y-websocket 서버] ←→ [Redis Pub/Sub] ←→ [다중 인스턴스]   │\n│          ↓                                                   │\n│  [PostgreSQL - 스냅샷 저장] + [S3 - 히스토리 아카이브]       │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### 핵심 구현 코드 (Yjs 예시)\n\n```typescript\n// 1. 문서 초기화\nimport * as Y from 'yjs'\nimport { WebsocketProvider } from 'y-websocket'\nimport { IndexeddbPersistence } from 'y-indexeddb'\n\nconst doc = new Y.Doc()\n\n// 2. 오프라인 지원 - IndexedDB에 자동 저장\nconst persistence = new IndexeddbPersistence('doc-id', doc)\n\n// 3. 실시간 동기화\nconst wsProvider = new WebsocketProvider(\n  'wss://your-server.com',\n  'doc-id',\n  doc\n)\n\n// 4. 협업 텍스트 편집\nconst yText = doc.getText('content')\n\n// 로컬 변경 → 즉시 반영 + 자동 동기화\nyText.insert(0, 'Hello ')\n\n// 5. 변경 감지\nyText.observe(event => {\n  console.log('변경됨:', event.changes)\n})\n\n// 6. 히스토리 (Undo/Redo)\nimport { UndoManager } from 'yjs'\nconst undoManager = new UndoManager(yText)\n\nundoManager.undo()  // 되돌리기\nundoManager.redo()  // 다시 실행\n```\n\n### 서버 구현 (Node.js)\n\n```typescript\n// y-websocket 서버\nimport { WebSocketServer } from 'ws'\nimport { setupWSConnection } from 'y-websocket/bin/utils'\n\nconst wss = new WebSocketServer({ port: 1234 })\n\nwss.on('connection', (ws, req) => {\n  setupWSConnection(ws, req, {\n    // 스냅샷 저장 콜백\n    persistence: {\n      provider: createPostgresPersistence(),\n      bindState: async (docName, ydoc) => {\n        // DB에서 문서 로드\n      },\n      writeState: async (docName, ydoc) => {\n        // DB에 문서 저장\n      }\n    }\n  })\n})\n```\n\n---\n\n## 50명 동시 편집 최적화\n\n```typescript\n// 1. Awareness (커서/선택 영역 공유) - 별도 채널\nconst awareness = wsProvider.awareness\n\nawareness.setLocalState({\n  user: { name: 'User A', color: '#ff0000' },\n  cursor: { index: 42 }\n})\n\n// 2. 청크 기반 로딩 (대용량 문서)\nconst loadSection = (sectionId: string) => {\n  return doc.getMap('sections').get(sectionId)\n}\n\n// 3. 변경 배치 처리 (네트워크 효율화)\ndoc.transact(() => {\n  yText.insert(0, 'a')\n  yText.insert(1, 'b')\n  yText.insert(2, 'c')\n}) // 하나의 업데이트로 전송\n```\n\n---\n\n## 히스토리 전략\n\n```\n실시간 레이어:    [현재 CRDT 상태] ← 최근 변경들\n                        ↓ 주기적 스냅샷 (예: 5분)\n스냅샷 레이어:    [스냅샷 1] → [스냅샷 2] → [스냅샷 3]\n                        ↓ 30일 이후 압축\n아카이브 레이어:  [월별 아카이브] → S3 Cold Storage\n```\n\n---\n\n## 마이그레이션 경로\n\n1. **Phase 1**: Yjs + y-websocket으로 MVP\n2. **Phase 2**: Redis Pub/Sub으로 서버 스케일아웃\n3. **Phase 3**: 커스텀 CRDT 타입 추가 (필요시)\n4. **Phase 4**: Diamond Types로 성능 크리티컬 부분 교체 (선택)\n\n---\n\n더 구체적인 구현 (에디터 통합, 권한 관리, 배포 등)에 대해 알려드릴까요?"
      },
      {
        "ai": "gemini",
        "content": "제안하신 요구사항(오프라인 지원, 자동 충돌 해결, Notion/Figma 스타일)을 고려했을 때, **B) CRDT (Conflict-free Replicated Data Types)** 방식을 강력히 추천합니다.\n\n이유와 구체적인 구현 전략을 아래와 같이 정리해 드립니다.\n\n### 1. 추천: CRDT (Conflict-free Replicated Data Types)\n\n**왜 CRDT인가요?**\n*   **오프라인 & 동기화 (핵심):** OT는 중앙 서버가 \"순서\"를 정해줘야 하므로 오프라인 상태에서 긴 작업을 하고 돌아왔을 때 병합 과정이 매우 복잡합니다. 반면 CRDT는 **교환 법칙(Commutative)**이 성립하여, 데이터의 변경 사항을 어떤 순서로 적용하든 최종 결과가 같음이 수학적으로 보장됩니다. 로컬에서 편집하고 나중에 네트워크에 연결만 하면 자연스럽게 동기화됩니다.\n*   **지연 시간:** 사용자 입력은 로컬에 즉시 반영(0ms)되고, 네트워크 전송은 비동기로 이루어지므로 100ms 이내 전파 요구사항을 충족하기 유리합니다.\n*   **충돌 해결:** \"마지막 쓰기 승리\"처럼 데이터를 덮어쓰는 게 아니라, 의도를 보존하며 병합합니다 (예: A와 B가 동시에 같은 위치에 글자를 쓰면 둘 다 보존됨).\n\n---\n\n### 2. 구현 전략\n\nNotion(블록 기반 텍스트)이나 Figma(객체 기반 캔버스)를 만들기 위한 CRDT 기반 아키텍처입니다.\n\n#### A. 핵심 라이브러리 선정\n직접 CRDT를 구현하는 것은 매우 어렵습니다. 검증된 라이브러리를 사용하세요.\n*   **Yjs (추천):** 성능이 매우 뛰어나고 생태계가 넓습니다. 텍스트 편집, 리스트 이동 등에 최적화되어 있습니다.\n*   **Automerge:** 기능이 강력하지만 Yjs보다 텍스트 처리 성능이 약간 떨어질 수 있습니다 (최근 버전에서 많이 개선됨).\n\n#### B. 데이터 구조 설계 (Notion 스타일 예시)\n문서를 하나의 거대한 텍스트가 아닌, **블록(Block)의 트리**로 모델링해야 합니다.\n\n1.  **문서 (Y.Doc):** 최상위 컨테이너.\n2.  **블록 리스트 (Y.Array):** 블록들의 순서를 관리합니다.\n3.  **블록 속성 (Y.Map):** 각 블록의 데이터(type, properties, children)를 저장합니다.\n4.  **텍스트 콘텐츠 (Y.Text):** 텍스트 블록 내부의 서식(Bold, Italic)과 내용을 관리합니다.\n\n#### C. 아키텍처 구성\n\n1.  **Frontend (Local-First):**\n    *   사용자의 모든 액션은 로컬의 Y.Doc에 즉시 반영됩니다.\n    *   **IndexedDB**를 사용하여 Y.Doc을 브라우저에 저장합니다. (오프라인 지원)\n    *   Network Provider(WebSocket, WebRTC)가 변경 사항(Update Binary)을 감지하여 서버/피어로 전송합니다.\n\n2.  **Backend (Signaling & Persistence):**\n    *   **역할:** CRDT는 P2P도 가능하지만, 50명 동시 편집과 안정성을 위해 중앙 중계 서버(Relay Server)가 필요합니다.\n    *   **기술:** Node.js + `y-websocket` 또는 Go/Rust로 작성된 WebSocket 서버.\n    *   **저장소:** 변경 사항(Update)을 지속적으로 DB(PostgreSQL, Redis, LevelDB)에 append-only 방식으로 저장합니다.\n\n#### D. 동시성 및 성능 최적화 (50명 + 100ms)\n\n*   **Update Merging:** 사용자가 입력할 때마다 모든 패킷을 보내면 네트워크가 폭주합니다. 짧은 시간(예: 10~50ms) 동안의 변경 사항을 모아서 하나의 패킷으로 전송합니다.\n*   **Snapshot:** 히스토리가 쌓이면 초기 로딩이 느려집니다. 서버는 주기적으로 변경 사항들을 병합하여 '스냅샷'을 만들고, 클라이언트는 스냅샷 + 이후 변경분만 로드하게 합니다.\n*   **Awareness Protocol:** 다른 사용자의 커서 위치나 선택 영역(Selection)은 CRDT 히스토리에 저장할 필요가 없습니다. 휘발성 메시지(Ephemeral message)로 WebSocket을 통해 가볍게 브로드캐스팅합니다.\n\n### 3. 단계별 실행 계획\n\n1.  **PoC (개념 증명):** `Yjs` + `TipTap`(텍스트 에디터) 또는 `Tldraw`(화이트보드)를 연결하여 `y-websocket` 데모 서버와 통신하는 프로토타입 제작.\n2.  **오프라인 모듈:** `y-indexeddb`를 붙여 인터넷을 끊고 편집 후 재접속 시 동기화되는지 테스트.\n3.  **백엔드 스토리지:** 메모리 기반 WebSocket 서버를 Redis/Postgres 연동형으로 교체하여 영구 저장 구현.\n4.  **최적화:** 문서가 커질 때를 대비해 Lazy Loading(하위 블록은 필요할 때 로드) 구현.\n\n**요약하자면:** **CRDT(Yjs)**를 코어로 잡고, **IndexedDB**로 오프라인을 처리하며, **WebSocket**으로 실시간 동기화를 맞추는 구조가 현재 업계 표준(De facto) 접근 방식입니다."
      },
      {
        "ai": "codex",
        "content": "CRDT(B)를 추천합니다. 요구사항(오프라인, 자동 충돌 해결, 100ms 지연, 무제한 히스토리)에 가장 자연스럽고 운영 리스크가 낮습니다. OT는 구현·운영 난도가 높고 오프라인/멀티디바이스 복구가 복잡합니다. Event Sourcing + LWW는 충돌과 데이터 손실 위험이 커서 “사용자 개입 최소화”와 정면 충돌합니다.\n\n구현 전략(핵심만):\n- 데이터 모델: 문서 구조별 CRDT 선택(텍스트는 RGA/Yjs Text, 도형/속성은 LWW-Element-Map + 벡터/람포트 타임스탬프)\n- 동기화: client‑side CRDT + 서버는 중계/스토리지 역할(“dumb relay”)\n- 네트워크: WebSocket + delta sync, 주기적 state snapshot + incremental update\n- 성능: 로컬 적용 즉시 반영, 원격 업데이트는 100ms 목표로 배치/압축(수십 ms)\n- 오프라인: 로컬 로그(업데이트/벡터 클럭) 저장, 온라인 복귀 시 diff sync\n- 히스토리: CRDT 업데이트 로그를 압축 저장 + 스냅샷 체인(가비지 컬렉션 정책만 설계)\n- 충돌: CRDT 규칙으로 자동 해결, UI에 최소한의 “최근 변경자” 표시만\n\n선택지 비교 요약:\n- OT: 실시간 성능은 가능하지만 서버 의존/변환 로직 복잡, 오프라인·복구 난도 높음\n- CRDT: 오프라인·충돌·히스토리에 강함, 구현 복잡도는 있지만 제품 요구와 정합\n- Event Sourcing + LWW: 빠르나 충돌 데이터 손실과 UX 이슈 큼\n\n원하면 CRDT 라이브러리(Yjs/Automerge) 기준으로 아키텍처/데이터 스키마/서버 프로토콜까지 구체화해 드릴게요."
      }
    ],
    "timeMs": 53464
  },
  "multiDebate": {
    "rounds": [
      {
        "ai": "claude",
        "content": "# 실시간 협업 도구 기술 선택 분석\n\n## 추천: B) CRDT (Conflict-free Replicated Data Types)\n\n요구사항을 분석했을 때 CRDT가 가장 적합합니다.\n\n---\n\n## 각 선택지 비교\n\n| 요구사항 | OT | CRDT | Event Sourcing + LWW |\n|---------|:---:|:----:|:--------------------:|\n| 50명 동시 편집 | △ | ◎ | ○ |\n| 100ms 지연시간 | ○ | ◎ | ○ |\n| 오프라인 지원 | ✗ | ◎ | △ |\n| 자동 충돌 해결 | ○ | ◎ | ✗ (데이터 손실) |\n| 무제한 히스토리 | ○ | ○ | ◎ |\n\n---\n\n## 왜 CRDT인가?\n\n### 1. 오프라인 지원이 결정적\nOT는 **중앙 서버 의존적**입니다. 오프라인에서 편집 후 동기화하려면 서버가 모든 변환을 순서대로 처리해야 하는데, 장시간 오프라인 후 병합은 매우 복잡합니다.\n\nCRDT는 **설계 자체가 분산 시스템용**입니다:\n- 각 클라이언트가 독립적으로 편집\n- 언제든 병합 가능, 순서 무관\n- 수학적으로 수렴 보장 (eventual consistency)\n\n### 2. 50명 동시 편집\nOT는 O(n²) 변환 복잡도로, 사용자가 늘어날수록 서버 부하가 급증합니다.\nCRDT는 클라이언트 측에서 병합하므로 서버 부하가 선형적입니다.\n\n### 3. LWW의 문제\nEvent Sourcing + LWW는 구현은 단순하지만:\n- 동시 편집 시 **한쪽 변경사항이 유실**됨\n- \"내가 쓴 글이 사라졌어요\" → 사용자 신뢰 하락\n\n---\n\n## 구현 전략\n\n### Phase 1: 기반 선택\n```\nYjs 또는 Automerge 사용 권장\n```\n\n**Yjs 추천 이유:**\n- 프로덕션 검증됨 (Notion, Linear 등 사용)\n- 다양한 에디터 바인딩 (ProseMirror, Monaco, Quill)\n- 메모리 효율적인 구현\n- y-indexeddb로 오프라인 저장 내장\n\n### Phase 2: 아키텍처\n\n```\n┌─────────────┐     WebSocket      ┌─────────────┐\n│   Client    │◄──────────────────►│   Server    │\n│             │                    │             │\n│  ┌───────┐  │                    │  ┌───────┐  │\n│  │  Yjs  │  │  sync updates      │  │  Yjs  │  │\n│  │  Doc  │◄─┼────────────────────┼─►│  Doc  │  │\n│  └───────┘  │                    │  └───────┘  │\n│      │      │                    │      │      │\n│      ▼      │                    │      ▼      │\n│ IndexedDB   │                    │  Database   │\n│ (offline)   │                    │ (persist)   │\n└─────────────┘                    └─────────────┘\n```\n\n### Phase 3: 핵심 컴포넌트\n\n```typescript\n// 1. 문서 동기화 (y-websocket 활용)\nconst doc = new Y.Doc()\nconst provider = new WebsocketProvider(\n  'wss://your-server.com',\n  'document-id',\n  doc\n)\n\n// 2. 오프라인 지원\nconst indexeddbProvider = new IndexeddbPersistence(\n  'document-id',\n  doc\n)\n\n// 3. Awareness (커서 위치, 사용자 상태)\nprovider.awareness.setLocalStateField('user', {\n  name: 'Alice',\n  cursor: { x: 100, y: 200 }\n})\n```\n\n### Phase 4: 히스토리 구현\n\n```typescript\n// Yjs UndoManager로 무제한 되돌리기\nconst undoManager = new Y.UndoManager(yText, {\n  trackedOrigins: new Set([doc.clientID])\n})\n\n// 스냅샷 기반 히스토리 (특정 시점 복원용)\nconst snapshot = Y.snapshot(doc)\n// 저장 후 나중에 복원\nY.applySnapshot(doc, snapshot)\n```\n\n---\n\n## 성능 최적화 팁\n\n1. **100ms 지연시간 달성**\n   - WebSocket 사용 (HTTP polling ✗)\n   - 업데이트 배칭 (16ms 간격)\n   - 바이너리 프로토콜 (y-protocols)\n\n2. **대용량 문서 처리**\n   - 청크 단위 로딩\n   - Lazy loading으로 보이는 부분만 렌더링\n\n3. **서버 비용 절감**\n   - Redis로 문서 상태 캐싱\n   - 유휴 문서는 메모리에서 해제\n\n---\n\n## 결론\n\nCRDT(Yjs)를 선택하면:\n- ✅ 오프라인 동기화가 자연스럽게 해결됨\n- ✅ 충돌 해결이 수학적으로 보장됨\n- ✅ 검증된 라이브러리로 빠른 개발 가능\n- ✅ 50명 동시 편집에도 확장성 확보\n\nOT는 순수 텍스트 편집에는 좋지만, 오프라인 요구사항 때문에 이 프로젝트에는 부적합합니다."
      },
      {
        "ai": "gemini",
        "content": "`obora`의 비전인 **\"리스크 감소와 블라인드 스팟 제거\"** 관점에서, 제안하신 실시간 협업 도구의 아키텍처를 심층 분석하여 추천안과 구현 전략을 제안합니다.\n\n---\n\n### 📋 아키텍처 리뷰 리포트: 실시간 협업 엔진 선택\n\n#### 🎯 최종 추천: B) CRDT (Conflict-free Replicated Data Types)\n요구사항인 **'오프라인 편집'**과 **'50명 동시 편집'**을 고려할 때, CRDT는 선택이 아닌 필수입니다. OT는 중앙 서버의 연산 부하와 오프라인 병합의 복잡성으로 인해 리스크가 큽니다.\n\n---\n\n### 🔍 주요 기술별 리스크 분석 (obora 관점)\n\n| 항목 | OT (Operational Transformation) | **CRDT (추천)** | LWW (Last Write Wins) |\n|:---|:---|:---|:---|\n| **복잡성** | 서버 로직이 매우 복잡함 (O(N²) 변환) | 데이터 모델 설계 시 메모리 관리 필요 | 구현은 쉬우나 데이터 유실 위험 높음 |\n| **확장성** | 서버가 모든 편집의 순서를 알아야 함 | **분산 처리 가능 (P2P 또는 Edge)** | 매우 높음 |\n| **사용자 경험** | 오프라인 후 온라인 시 충돌 발생 가능 | **자연스러운 병합, 의도 보존** | 마지막에 저장한 사람만 남음 (분노 유발) |\n| **결정적 리스크** | 서버 장애 시 전체 협업 중단 | **Tombstone(삭제된 데이터) 누적** | **데이터 무결성 파괴** |\n\n---\n\n### 🛠️ 단계별 구현 전략 (Phase-by-Phase)\n\n#### Phase 1: 기반 엔진 및 데이터 모델 (The Core)\n- **라이브러리**: `Yjs` 추천 (성능 및 생태계 우위).\n- **데이터 구조**: 문서를 단일 텍스트가 아닌 **Shared Types(Y.Map, Y.Array, Y.Text)의 트리 구조**로 설계. Notion처럼 '블록' 단위로 데이터를 쪼개면 CRDT 성능 최적화와 권한 관리가 용이합니다.\n\n#### Phase 2: 실시간 전송 및 동기화 (Networking)\n- **전송 계층**: `y-websocket`을 기본으로 하되, 50명 동시 접속 시 부하 분산을 위해 **Pub/Sub 서버(Redis/Nats)** 도입.\n- **바이너리 프로토콜**: Yjs의 `Update`는 바이너리(Uint8Array) 형태이므로 네트워크 대역폭 효율이 높습니다. 100ms 지연시간 달성을 위해 전송 전 배칭(Batching) 처리를 수행합니다.\n\n#### Phase 3: 오프라인 및 영속화 (Persistence)\n- **클라이언트**: `IndexedDB`를 사용하여 브라우저 종료 후에도 편집 내역 유지. 온라인 복귀 시 Yjs가 자동으로 Diff를 계산해 동기화합니다.\n- **서버**: PostgreSQL의 `BYTEA` 필드나 NoSQL에 Yjs 업데이트 로그를 저장. 정기적으로 '스냅샷'을 찍어 초기 로딩 속도를 최적화합니다.\n\n#### Phase 4: 고급 기능 (UX & Safety)\n- **Awareness**: `provider.awareness`를 통해 사용자 커서, 타이핑 상태를 100ms 이내로 공유.\n- **History**: Yjs의 `UndoManager`를 사용하되, 특정 사용자의 작업만 되돌리는 'Scoped Undo'를 구현하여 50명 혼선 방지.\n\n---\n\n### ⚠️ 주의해야 할 \"블라인드 스팟\" (obora의 경고)\n\n1.  **메모리 관리 (Tombstones)**: CRDT는 삭제된 데이터도 기록을 남깁니다. 문서가 수년간 유지될 경우 메모리 사용량이 늘어날 수 있으므로, 주기적으로 문서를 'Garbage Collect'하거나 새로운 버전으로 아카이빙하는 전략이 필요합니다.\n2.  **보안/권한**: CRDT는 클라이언트가 업데이트를 생성합니다. 악의적인 클라이언트가 문서 전체를 삭제하는 업데이트를 쏘지 못하도록, **서버 측에서 업데이트 검증(Validation)** 로직을 반드시 추가해야 합니다.\n3.  **대용량 문서**: 50명이 수만 줄의 문서를 동시에 편집하면 초기 로딩(Initial Sync)이 느려질 수 있습니다. 'Lazy Loading' 기법을 도입하여 현재 보고 있는 섹션부터 우선 동기화해야 합니다.\n\n**이 설계안에 대해 특정 부분(예: 구체적인 서버 스택, 보안 검증 로직 등)을 더 심층적으로 검토해 드릴까요?** (예: `obora review --deep architecture.yaml`)"
      },
      {
        "ai": "codex",
        "content": "CRDT(B)를 추천합니다. 오프라인 편집 + 자동 충돌 해결 + 100ms 내 반영을 동시에 만족하는 유일한 선택지입니다. OT는 중앙 서버 변환 의존성과 오프라인 병합 복잡성이 커지고, LWW는 데이터 유실로 협업 UX를 깨뜨립니다.\n\n**추천 이유 요약**\n- 오프라인: CRDT는 순서 무관 병합으로 자연스럽게 동기화됩니다.\n- 100ms: 로컬 적용 → WebSocket으로 delta 전파하면 지연 요구 충족.\n- 자동 충돌: 수학적으로 수렴 보장, 사용자 개입 최소화.\n- 무제한 히스토리: 업데이트 로그/스냅샷 기반으로 복원 가능.\n\n**구현 전략(실전)**\n1) **라이브러리 선택**\n- 웹: `Yjs`(프로덕션 사례 많음, 성능/생태계 우수)\n- 멀티플랫폼: `Automerge`도 대안\n2) **데이터 모델**\n- 문서 전체를 단일 텍스트로 두지 말고 “블록 단위” CRDT 구조(Y.Map/Y.Array/Y.Text)로 설계.\n- Notion처럼 블록 트리 구조로 하면 성능/권한/부분 로딩에 유리.\n3) **동기화 계층**\n- WebSocket 기반 provider(y-websocket)로 delta 전송\n- 16~32ms 배칭 + 바이너리 업데이트 전송\n- Awareness(커서/선택) 별도 채널로 짧은 TTL 전파\n4) **오프라인**\n- 클라이언트: IndexedDB에 로컬 업데이트 저장\n- 온라인 복귀 시 CRDT update 병합 자동 수행\n5) **저장/히스토리**\n- 서버: 업데이트 로그 + 주기적 스냅샷 저장\n- 무제한 Undo: `UndoManager` 또는 사용자별 operation 로그로 구현\n6) **성능/안정성**\n- 대문서: 섹션별 lazy loading(필요 블록만 동기화)\n- GC/압축: tombstone 누적 방지용 compaction 주기화\n\n**피해야 할 선택**\n- LWW(Event Sourcing): 구현은 쉽지만 실시간 협업에서 변경 유실이 빈번 → 신뢰도 하락\n- OT: 오프라인 지원과 50명 동시 편집 조건에서 서버 부담/복잡성 커짐\n\n원하시면 다음 중 어디부터 구체화할지 알려주세요.\n1) Yjs 기반 구체적 데이터 모델 설계(블록 스키마)\n2) 서버 아키텍처(스냅샷/로그/캐시 전략)\n3) 100ms 지연 달성 위한 네트워크 튜닝/배칭 전략"
      }
    ],
    "conclusion": "## 토론 결론: CRDT (Conflict-free Replicated Data Types) 채택\n\n### 🎯 핵심 합의점\n\n세 AI 모두 **B) CRDT 선택**에 완전히 동의합니다:\n\n1. **오프라인 지원의 결정성**\n   - CRDT는 순서 무관 병합으로 자연스러운 동기화\n   - OT는 중앙 서버 의존도 높음, 오프라인 병합 복잡\n\n2. **50명 동시 편집 확장성**\n   - CRDT: 클라이언트 측 병합으로 서버 부하 선형적\n   - OT: O(N²) 변환 복잡도로 부하 급증\n\n3. **자동 충돌 해결의 안정성**\n   - CRDT: 수학적 수렴 보장\n   - LWW: 데이터 유실 리스크 (사용자 신뢰 하락)\n\n4. **실증성**\n   - Figma, Notion, Linear 등 프로덕션 검증됨\n\n---\n\n### ⚠️ 주요 이견점 및 강조 차이\n\n**Claude**: 기술 선택의 실용성에 포커스\n- Yjs 라이브러리 추천\n- Phase별 단계적 구현 전략\n- 성능 최적화 팁 (100ms 달성법)\n\n**Gemini** (obora): 리스크 관리와 블라인드 스팟 강조\n- **메모리 관리 (Tombstones)**: 장기 운영 시 메모리 누적 문제\n- **보안/권한**: 클라이언트 업데이트 검증 필수\n- **대용량 문서**: Lazy Loading 전략 필수\n\n**Codex**: 의사결정 속도와 실전성\n- 라이브러리 선택지 비교 (Yjs vs Automerge)\n- 구체적 구현 전략 6단계\n- \"블록 단위 설계\"의 중요성 강조\n\n---\n\n### ✅ 최종 권장사항\n\n#### 1단계: 기반 구축\n```\n라이브러리: Yjs (프로덕션 검증, 생태계 우수)\n데이터 모델: 단일 텍스트 X → 블록 트리 구조 (Y.Map/Y.Array)\n동기화: y-websocket + Redis Pub/Sub (50명 부하 분산)\n```\n\n#### 2단계: 오프라인 + 히스토리\n```\n클라이언트: IndexedDB (로컬 저장)\n서버: 업데이트 로그 + 주기적 스냅샷\n히스토리: UndoManager + 스냅샷 기반 복원\n```\n\n#### 3단계: 성능 최적화 (100ms 달성)\n```\n- WebSocket 배칭 (16~32ms)\n- 바이너리 프로토콜 (y-protocols)\n- Awareness 별도 채널 (커서/상태)\n```\n\n#### 4단계: 리스크 관리 (Gemini 강조)\n```\n- 메모리 GC: 주기적 compaction으로 tombstone 정리\n- 보안: 서버 측 업데이트 검증 로직 필수\n- 대문서: 섹션별 lazy loading 구현\n```\n\n---\n\n### 📊 의사결정 매트릭스\n\n| 선택지 | 오프라인 | 동시편집 | 자동충돌 | 구현복잡도 | 운영리스크 |\n|:---|:---:|:---:|:---:|:---:|:---:|\n| **A) OT** | ✗ | △ | ○ | 높음 | 높음 |\n| **B) CRDT** ✅ | ◎ | ◎ | ◎ | 중간 | 중간 |\n| **C) LWW** | ◎ | ○ | ✗ | 낮음 | 매우 높음 |\n\n---\n\n### 🚀 다음 액션 아이템\n\n1. **Yjs 프로토타입**: 간단한 협업 문서 편집 (1주)\n2. **블록 스키마 설계**: Notion 스타일 계층 구조 (1주)\n3. **보안 검증 로직**: 서버 측 업데이트 검증 (병렬)\n4. **성능 테스트**: 50명 동시 편집 시뮬레이션 (병렬)\n\n**의사결정 완료: CRDT (Yjs) 기반 실시간 협업 도구 개발 추진**",
    "timeMs": 139128
  },
  "analysis": {
    "singleLength": 4427,
    "parallelLength": 7768,
    "debateLength": 6122,
    "debateRounds": 3
  }
}