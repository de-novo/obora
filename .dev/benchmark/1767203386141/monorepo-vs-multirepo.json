{
  "caseId": "monorepo-vs-multirepo",
  "caseName": "모노레포 vs 멀티레포 전략",
  "caseType": "tech",
  "category": "architecture",
  "controversyLevel": "high",
  "singleAI": {
    "response": "# 코드 저장소 전략 추천\n\n## 결론: **A) 모노레포 통합** 추천\n\n현재 상황과 성장 계획을 고려할 때, 모노레포가 가장 적합합니다.\n\n---\n\n## 판단 근거\n\n### 현재 문제와 해결책 매칭\n\n| 문제 | 모노레포 해결 | 멀티레포 해결 |\n|------|-------------|--------------|\n| 공유 라이브러리 버전 불일치 | **즉시 해결** - 단일 버전 | 부분 해결 - 여전히 동기화 필요 |\n| 통합 테스트 어려움 | **즉시 해결** - 한 번에 테스트 | 별도 CI 파이프라인 구축 필요 |\n| PR 리뷰 분산 | **해결** - 한 곳에서 리뷰 | 해결 불가 |\n\n### 팀 구조가 모노레포에 유리\n\n```\n현재: 풀스택 8명 → 모두가 여러 서비스 터치\n     ↓\n모노레포 = 자연스러운 선택\n\n만약: 팀별 서비스 분리 (API팀, 프론트팀 등)\n     ↓\n멀티레포도 고려 가능\n```\n\n**핵심**: 팀 경계 없이 협업하는 구조에서 레포가 분리되면 마찰만 증가합니다.\n\n### 규모 적합성\n\n```\n8명 → 15명, 6개 → 10개 서비스\n\n이 규모는 모노레포의 \"스윗 스팟\"\n- Google/Meta 수준 (수천 명) → 커스텀 도구 필요\n- 스타트업 15명 → Turborepo/Nx로 충분\n```\n\n---\n\n## 옵션별 비교\n\n### A) 모노레포 (Turborepo 추천)\n\n**장점**\n- 원자적 변경: 라이브러리 + 사용처 한 번에 수정/배포\n- 의존성 단일 관리: package.json 한 곳\n- 빠른 온보딩: 새 개발자가 `git clone` 한 번으로 전체 파악\n- 리팩토링 용이: 전체 영향 범위 즉시 확인\n\n**단점**\n- 초기 마이그레이션 비용 (1-2주)\n- CI 파이프라인 재구성 필요\n- 레포 크기 증가 (관리 가능한 수준)\n\n### B) 멀티레포 유지\n\n**장점**\n- 마이그레이션 비용 없음\n- 레포별 독립 배포\n\n**단점**\n- 현재 문제 근본 해결 불가\n- 공유 라이브러리 버전 관리 → Renovate/Dependabot으로 개선 가능하나 완전하지 않음\n- 성장할수록 복잡도 증가\n\n### C) 하이브리드\n\n**비추천 이유**\n- 복잡도만 증가 (어디까지가 모노? 멀티?)\n- 팀 구조와 불일치 (풀스택이 모든 서비스 터치)\n- 추후 완전 모노레포로 재마이그레이션 가능성\n\n---\n\n## 도구 선택: Turborepo vs Nx\n\n| 기준 | Turborepo | Nx |\n|------|-----------|-----|\n| 학습 곡선 | **낮음** | 높음 |\n| 설정 복잡도 | **간단** | 상세 |\n| 캐싱 | 우수 | 우수 |\n| 생태계 | Vercel 통합 | 풍부한 플러그인 |\n| 추천 상황 | **JS/TS 중심, 빠른 도입** | 다양한 언어, 세밀한 제어 |\n\n**추천: Turborepo** - 8명 팀에서 빠르게 도입하고 효과 보기에 적합\n\n---\n\n## 마이그레이션 체크리스트\n\n```\n1. 모노레포 구조 설계\n   - packages/shared-* (공유 라이브러리 3개)\n   - apps/api\n   - apps/web-*\n   - apps/mobile\n\n2. Turborepo 초기 설정\n   - turbo.json 구성\n   - 워크스페이스 설정 (pnpm/yarn)\n\n3. CI/CD 재구성\n   - 변경된 패키지만 빌드 (turbo affected)\n   - 서비스별 배포 파이프라인 유지\n\n4. 기존 레포 히스토리 마이그레이션 (선택)\n   - git subtree 또는 새로 시작\n```\n\n---\n\n## 요약\n\n> **모노레포 + Turborepo**가 현재 팀 구조(경계 없는 풀스택 협업)와 성장 계획(15명, 10개 서비스)에 가장 적합합니다. 지금 전환하면 마이그레이션 비용이 작고, 미루면 커집니다.",
    "timeMs": 36332
  },
  "multiParallel": {
    "responses": [
      {
        "ai": "claude",
        "content": "# 코드 저장소 전략 추천: **A) 모노레포 통합**\n\n현재 상황을 분석하면 **모노레포가 가장 적합**합니다.\n\n---\n\n## 핵심 판단 근거\n\n### 현재 문제와 해결책 매칭\n\n| 현재 문제 | 모노레포 해결 방식 |\n|----------|-------------------|\n| 공유 라이브러리 버전 불일치 | 단일 버전 소스 - 항상 최신 코드 참조 |\n| 통합 테스트 어려움 | 한 번의 CI로 전체 영향 범위 테스트 |\n| PR 리뷰 분산 | 관련 변경사항을 단일 PR로 묶음 |\n\n### 팀 구조가 모노레포에 최적\n\n```\n현재: 8명 풀스택 → 기능별 분업 없음 → 여러 서비스 동시 터치\n                                         ↓\n                         멀티레포: 하나의 기능에 6개 PR 필요\n                         모노레포: 하나의 PR로 완결\n```\n\n**\"모두가 여러 서비스를 터치한다\"** → 이건 모노레포의 교과서적 사용 사례입니다.\n\n---\n\n## 왜 B, C는 비추천인가\n\n### B) 멀티레포 유지 + 라이브러리 개선\n\n- 버전 관리 오버헤드 지속 (semantic versioning, changelog, publish)\n- 15명 + 10개 서비스 시 조합 복잡도 폭발\n- 라이브러리 변경 시 N개 레포에 PR 생성 필요\n\n### C) 하이브리드 (프론트만 모노레포)\n\n- API-프론트엔드 간 타입/스키마 공유 문제 미해결\n- 경계 설정 애매 → 관리 포인트 증가\n- 결국 완전 통합으로 가는 과도기일 뿐\n\n---\n\n## 도구 선택: Turborepo vs Nx\n\n| 기준 | Turborepo | Nx |\n|------|-----------|-----|\n| 학습 곡선 | 낮음 | 높음 |\n| 설정 복잡도 | 간단 | 상세 |\n| 캐싱 | 우수 | 우수 |\n| 생태계 | 가벼움 | 풍부 (generators, plugins) |\n| 추천 시점 | 지금 (8명, 7개 서비스) | 20명+ 또는 세밀한 제어 필요시 |\n\n**추천: Turborepo로 시작** → 필요시 Nx 마이그레이션 (역방향보다 쉬움)\n\n---\n\n## 마이그레이션 단계\n\n```\n1단계: 공유 라이브러리 3개 먼저 통합\n       └─ 가장 빈번한 버전 충돌 해결\n\n2단계: API 서버 추가\n       └─ 타입 공유, E2E 테스트 통합\n\n3단계: 웹 프론트엔드 2개 추가\n       └─ 컴포넌트/유틸 공유 극대화\n\n4단계: 모바일 앱 추가 (선택적)\n       └─ React Native면 통합, Native면 별도 레포 유지 고려\n```\n\n---\n\n## 주의할 점\n\n1. **CODEOWNERS 설정** - 15명 되면 모든 PR에 모두 리뷰 불가\n2. **영향 범위 기반 CI** - `turbo run build --filter=...[origin/main]`\n3. **패키지 경계 명확히** - 처음부터 `packages/`, `apps/` 구조 확립\n\n---\n\n## 결론\n\n> 8명이 6개 레포를 넘나들며 일하는 건 비효율의 극치입니다.\n> \n> 지금 통합하면 1년 뒤 15명/10개 서비스에서 훨씬 수월합니다.\n> 나중에 하면 마이그레이션 비용만 커집니다.\n\n**Turborepo 기반 모노레포 통합을 추천합니다.**"
      },
      {
        "ai": "gemini",
        "content": "**A) 모노레포로 통합 (Turborepo/Nx)** 전략을 강력하게 추천합니다.\n\n현재 **8명의 풀스택 개발자**가 있고, 향후 **15명 규모로 성장**하며 **서비스가 늘어나는** 상황에서 모노레포는 가장 효율적인 선택입니다. 특히 이미 프로젝트 구조(`turbo.json`, `bun.lock`, `packages/` 등)가 모노레포 형태를 띠고 있으므로, 이 방향을 확고히 하는 것이 좋습니다.\n\n### 추천 이유\n\n1.  **풀스택 팀의 워크플로우 최적화**\n    *   팀원들이 기능별 분업 없이 모든 서비스를 건드린다면, **\"Atomic Commit\"**이 필수적입니다. API 수정, 공용 라이브러리 업데이트, 프론트엔드 반영을 **단 하나의 PR**로 처리할 수 있어, 레포지토리 간 컨텍스트 스위칭 비용이 사라집니다.\n\n2.  **공유 라이브러리 의존성 지옥 해결 (Dependency Hell)**\n    *   가장 큰 고통인 \"버전 불일치\"가 즉시 해결됩니다. 모노레포 내에서는 모든 서비스가 공유 라이브러리의 **최신 코드(HEAD)**를 바라보게 되므로, 별도의 npm 배포나 `npm link` 과정 없이 수정 사항이 즉시 모든 서비스에 반영됩니다.\n\n3.  **인프라/설정 관리 비용 절감**\n    *   서비스가 10개로 늘어날 때, 멀티레포는 CI/CD 파이프라인, 린트(Lint), TSConfig 설정을 10번 복사/붙여넣기 해야 합니다. 모노레포는 이를 한곳에서 중앙 집중식으로 관리하므로 확장성이 뛰어납니다.\n\n4.  **현재 기술 스택과의 궁합 (Bun + Turbo)**\n    *   보여주신 파일 목록에 `bun.lock`과 `turbo.json`이 이미 존재합니다. **Bun**의 빠른 패키지 설치 속도와 **Turborepo**의 강력한 캐싱 기능은 모노레포의 유일한 단점인 '빌드 속도 저하'를 효과적으로 상쇄하는 최신 조합입니다.\n\n### 실행 전략 및 주의사항\n\n*   **구조 제안:**\n    *   `apps/`: API 서버, 프론트엔드, 모바일 앱 (배포 가능한 애플리케이션)\n    *   `packages/`: 공유 UI 컴포넌트, API 타입 정의, 유틸리티, ESLint/TSConfig 설정 (npm 배포용이 아닌 내부 참조용)\n*   **필수 도입:** **Turborepo Remote Caching**을 반드시 설정하세요. 팀원이 늘어날수록 로컬 빌드 시간을 획기적으로 줄여주며, CI 비용을 아껴줍니다.\n*   **코드 오너십:** 인원이 15명으로 늘어나면, `CODEOWNERS` 파일을 통해 특정 디렉토리(예: 결제 모듈, 핵심 코어)의 리뷰어를 지정하여 무분별한 변경을 방지하세요.\n\n결론적으로, 현재의 성장 속도와 팀 구성(풀스택)을 고려할 때 **모노레포**는 선택이 아니라 필수적인 진화 방향입니다."
      },
      {
        "ai": "codex",
        "content": "현재 상황과 1년 내 성장 예측을 보면 A) 모노레포 통합을 추천합니다.  \n이유: 풀스택 8명이 여러 서비스 터치하는 구조에서 공유 라이브러리 버전 불일치/통합 테스트/PR 분산 문제가 이미 발생했고, 서비스 수가 10개+로 늘면 멀티레포 비용이 더 급증합니다. 모노레포는 의존성 정합성, 변경 영향 범위 가시성, 통합 테스트/CI 효율에서 가장 큰 개선 효과가 납니다.\n\n추천 전략(요약)\n- 모노레포로 전환하고 Turborepo/Nx로 캐시·타겟 빌드 최적화.\n- 공유 라이브러리는 workspace 패키지로 관리해 버전 불일치 제거.\n- 통합 테스트/릴리스 파이프라인을 표준화해 PR 리뷰 분산 최소화.\n\n주의/보완\n- 초기 전환 비용이 크므로 단계적 마이그레이션(공유 라이브러리 → 프론트엔드 → API/모바일) 추천.\n- 모듈 경계/소유권 룰, lint/CI 규칙을 먼저 합의해야 효과가 큼.\n\nB는 문제를 부분 완화할 뿐이며 성장 시 비용이 다시 커집니다. C는 일부 개선은 되지만 핵심 문제(공유 라이브러리, 통합 테스트, 리뷰 분산)를 완전히 해결하지 못합니다."
      }
    ],
    "timeMs": 43606
  },
  "multiDebate": {
    "rounds": [
      {
        "ai": "claude",
        "content": "# 추천: A) 모노레포로 통합\n\n현재 상황과 향후 계획을 고려했을 때, **모노레포 전환**을 권장합니다.\n\n---\n\n## 판단 근거\n\n### 현재 문제점과 해결책 매칭\n\n| 문제 | 모노레포 해결 |\n|------|-------------|\n| 공유 라이브러리 버전 불일치 | 단일 버전, 즉시 반영 |\n| 통합 테스트 어려움 | 한 번의 CI로 전체 테스트 |\n| PR 리뷰 분산 | 관련 변경사항 단일 PR로 묶음 |\n\n### 팀 구조가 모노레포에 적합\n\n8명 풀스택 개발자가 **여러 서비스를 동시에 터치**하는 구조는 모노레포의 핵심 사용 사례입니다. 멀티레포에서는 하나의 기능을 위해 3-4개 레포에 걸쳐 PR을 올려야 하는 상황이 발생합니다.\n\n### 규모 적정성\n\n- 현재 7개 패키지 → 1년 후 10개+ 예상\n- 이 규모는 모노레포 도구들이 가장 잘 처리하는 범위\n- 너무 작지도, 너무 크지도 않음\n\n---\n\n## 도구 선택: Turborepo vs Nx\n\n**Turborepo 권장** (현재 규모 기준)\n\n- 설정이 단순함 (기존 npm/pnpm workspace에 추가)\n- 학습 곡선 낮음\n- 캐싱만으로도 상당한 빌드 속도 개선\n\nNx는 더 강력하지만 설정 복잡도가 높아 15명 이상, 20개+ 패키지 시점에 재검토해도 늦지 않습니다.\n\n---\n\n## B, C 옵션을 권장하지 않는 이유\n\n**B) 멀티레포 유지**: 현재 문제의 근본 원인을 해결하지 못함. 공유 라이브러리 개선만으로는 버전 동기화 문제가 계속됨.\n\n**C) 하이브리드**: 복잡도만 증가. \"어디까지가 모노레포인가\" 경계 관리 부담. 팀 규모 대비 오버헤드.\n\n---\n\n## 마이그레이션 접근법\n\n1. 새 모노레포 생성 + pnpm workspace 설정\n2. 공유 라이브러리 3개 먼저 이전\n3. 프론트엔드 2개 이전 (라이브러리 의존성 테스트)\n4. API 서버 이전\n5. 모바일 앱 이전 (React Native 가정 시 workspace 통합 가능)\n6. 기존 레포 archive\n\n---\n\n## 주의사항\n\n- CI 파이프라인 재설계 필요 (affected 기반 빌드)\n- 초기 2-3주 생산성 저하 감수\n- 모바일 앱이 네이티브(Swift/Kotlin)라면 별도 레포 유지 검토"
      },
      {
        "ai": "gemini",
        "content": "저도 **A) 모노레포로의 통합**이 최선의 선택이라는 Claude의 의견에 **전적으로 동의합니다.**\n\n특히 **\"풀스택 개발자 8명이 기능별 분업 없이 여러 서비스를 터치한다\"**는 팀의 업무 방식이 모노레포 도입의 가장 강력한 근거입니다.\n\nClaude의 분석이 매우 정확하므로, 저는 실제 도입 시 고려해야 할 **현실적인 디테일과 추가적인 조언**을 덧붙이겠습니다.\n\n---\n\n### 1. 가장 큰 이점은 '아토믹 커밋(Atomic Commit)'\nClaude가 언급한 'PR 리뷰 분산 해결'을 좀 더 구체화하면, **\"백엔드 API 변경과 프론트엔드 반영을 하나의 커밋(PR)으로 처리할 수 있다\"**는 점입니다.\n- **현재:** API 레포 수정(PR) → 배포 → 라이브러리 버전 업 → 프론트엔드 레포 수정(PR) (이 과정에서 버전 꼬임 발생)\n- **모노레포:** `packages/api-types` 수정 + `apps/backend` 수정 + `apps/frontend` 수정 = **1개의 PR**\n- 이 워크플로우 변화가 팀의 개발 속도를 비약적으로 높여줄 것입니다.\n\n### 2. 모바일 앱(Mobile App) 통합에 대한 현실적 조언\n모바일 앱의 기술 스택에 따라 전략을 세분화해야 합니다.\n\n*   **React Native / Expo인 경우:** **무조건 모노레포에 포함**시키세요. 웹 프론트엔드와 비즈니스 로직, 타입, 유틸리티를 공유하는 이점이 엄청납니다. `react-native-monorepo` 등의 도구들이 잘 나와 있습니다.\n*   **Native (Swift/Kotlin)인 경우:** **신중해야 합니다.** Xcode나 Android Studio의 빌드 설정을 JS 기반 모노레포 툴체인(Turborepo 등)과 엮는 것은 꽤 번거로운 작업이 될 수 있습니다. 팀 내에 모바일 빌드 환경을 능숙하게 다룰 엔지니어가 없다면, 초기에는 모바일만 별도 레포로 두거나, 모노레포 안에 두되 빌드 파이프라인만 분리하는 것도 방법입니다.\n\n### 3. 'Remote Caching'은 필수\nTurborepo를 도입한다면 **Remote Caching(원격 캐싱)** 설정은 선택이 아니라 필수입니다.\n- 로컬 캐싱만으로는 팀원 간의 빌드 속도 향상을 체감하기 어렵고, CI 속도도 획기적으로 줄지 않습니다.\n- Vercel을 쓰지 않더라도 자체적인 Remote Cache 서버를 구축하거나 관련 솔루션을 사용하여, 동료 A가 빌드한 결과물을 동료 B가 즉시 재사용할 수 있게 해야 합니다.\n\n### 4. 의존성 관리 도구 도입 (Syncpack)\n모노레포로 합치면 `package.json`이 10개 이상 생깁니다. 이때 각 패키지마다 `React`, `Lodash` 등의 버전이 달라지면 '유령 의존성(Phantom Dependency)' 문제나 번들 사이즈 증가 문제가 발생합니다.\n- **조언:** `syncpack` 같은 도구를 CI에 붙여서, 모노레포 내의 모든 패키지가 동일한 버전의 외부 라이브러리를 사용하도록 강제하는 것이 좋습니다.\n\n### 5. 마이그레이션 순서에 대한 첨언\nClaude의 마이그레이션 단계도 훌륭하지만, **0단계**를 추가하고 싶습니다.\n- **0단계: 린트(Lint)와 포맷터(Prettier) 통일**\n- 6개의 레포가 미묘하게 다른 룰을 쓰고 있을 확률이 높습니다. 합치고 나서 코드를 건드릴 때마다 포맷팅 때문에 diff가 발생하면 지옥이 펼쳐집니다. 합치기 전에, 혹은 합치는 순간에 가장 엄격한 기준으로 룰을 통일하는 작업을 선행하세요.\n\n### 요약 및 결론\n**Turborepo + pnpm Workspace** 조합으로 가시는 것을 강력 추천합니다.\n팀이 15명으로 늘어나더라도, 이 구조는 충분히 버틸 수 있으며 오히려 온보딩 비용을 획기적으로 줄여줄 것입니다. (신규 입사자는 레포 하나만 clone 받으면 바로 개발 환경 세팅이 끝나니까요.)"
      },
      {
        "ai": "codex",
        "content": "A) 모노레포 통합을 추천합니다. 이유는 현재 pain point가 모노레포의 핵심 장점과 정면으로 맞물려 있고(공유 라이브러리 버전 불일치, 통합 테스트, PR 분산), 팀이 기능별 분업 없이 여러 서비스에 손대는 구조라 단일 PR/원자적 변경의 효과가 큽니다. 1년 내 서비스 10개+ 규모는 Turborepo/Nx가 가장 효율적으로 다루는 구간입니다.\n\n보완 고려사항만 짚으면:\n- 모바일이 RN/Expo면 모노레포에 포함, 네이티브면 빌드 파이프라인 분리 또는 초기엔 별도 레포 유지 검토.\n- Turborepo + pnpm workspace 조합이 현재 규모에서 설정/학습 비용 대비 효과가 좋습니다.\n- Remote caching 도입은 체감 효과를 결정하는 핵심이므로 초기부터 포함하세요.\n\nB는 문제의 뿌리를 해결하지 못하고, C는 경계 관리가 복잡해져 오버헤드가 큽니다."
      }
    ],
    "conclusion": "세 AI 분석(Claude, Gemini, Codex)이 모두 A) 모노레포 통합을 최적의 선택으로 일치했습니다. Turborepo + pnpm workspace 조합으로 시작하며, Remote Caching과 의존성 관리 도구(syncpack) 도입이 필수입니다. 모바일 앱의 기술 스택(RN/Expo vs Native)에 따라 통합 방식을 조정하고, 단계적 마이그레이션을 통해 리스크를 최소화합니다. 이 구조는 향후 팀 15명, 서비스 10개+ 규모까지 충분히 확장 가능합니다.",
    "timeMs": 115836
  },
  "analysis": {
    "singleLength": 1871,
    "parallelLength": 3592,
    "debateLength": 3485,
    "debateRounds": 3
  }
}